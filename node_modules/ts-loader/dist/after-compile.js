"use strict";
var path = require('path');
var utils = require('./utils');
function makeAfterCompile(instance, configFilePath) {
    var compiler = instance.compiler, languageService = instance.languageService;
    var getCompilerOptionDiagnostics = true;
    var checkAllFilesForErrors = true;
    return function (compilation, callback) {
        // Don't add errors for child compilations
        if (compilation.compiler.isChild()) {
            callback();
            return;
        }
        removeTSLoaderErrors(compilation.errors);
        // handle compiler option errors after the first compile
        if (getCompilerOptionDiagnostics) {
            getCompilerOptionDiagnostics = false;
            utils.registerWebpackErrors(compilation.errors, utils.formatErrors(languageService.getCompilerOptionsDiagnostics(), instance.loaderOptions, compiler, { file: configFilePath || 'tsconfig.json' }));
        }
        // build map of all modules based on normalized filename
        // this is used for quick-lookup when trying to find modules
        // based on filepath
        var modules = {};
        compilation.modules.forEach(function (module) {
            if (module.resource) {
                var modulePath = path.normalize(module.resource);
                if (utils.hasOwnProperty(modules, modulePath)) {
                    var existingModules = modules[modulePath];
                    if (existingModules.indexOf(module) === -1) {
                        existingModules.push(module);
                    }
                }
                else {
                    modules[modulePath] = [module];
                }
            }
        });
        // gather all errors from TypeScript and output them to webpack
        var filesWithErrors = {};
        // calculate array of files to check
        var filesToCheckForErrors = null;
        if (checkAllFilesForErrors) {
            // check all files on initial run
            filesToCheckForErrors = instance.files;
            checkAllFilesForErrors = false;
        }
        else {
            filesToCheckForErrors = {};
            // check all modified files, and all dependants
            Object.keys(instance.modifiedFiles).forEach(function (modifiedFileName) {
                collectAllDependants(instance, modifiedFileName).forEach(function (fName) {
                    filesToCheckForErrors[fName] = instance.files[fName];
                });
            });
        }
        // re-check files with errors from previous build
        if (instance.filesWithErrors) {
            Object.keys(instance.filesWithErrors).forEach(function (fileWithErrorName) {
                return filesToCheckForErrors[fileWithErrorName] = instance.filesWithErrors[fileWithErrorName];
            });
        }
        Object.keys(filesToCheckForErrors)
            .filter(function (filePath) { return !!filePath.match(/(\.d)?\.ts(x?)$/); })
            .forEach(function (filePath) {
            var errors = languageService.getSyntacticDiagnostics(filePath).concat(languageService.getSemanticDiagnostics(filePath));
            if (errors.length > 0) {
                if (null === filesWithErrors) {
                    filesWithErrors = {};
                }
                filesWithErrors[filePath] = instance.files[filePath];
            }
            // if we have access to a webpack module, use that
            if (utils.hasOwnProperty(modules, filePath)) {
                var associatedModules = modules[filePath];
                associatedModules.forEach(function (module) {
                    // remove any existing errors
                    removeTSLoaderErrors(module.errors);
                    // append errors
                    var formattedErrors = utils.formatErrors(errors, instance.loaderOptions, compiler, { module: module });
                    utils.registerWebpackErrors(module.errors, formattedErrors);
                    utils.registerWebpackErrors(compilation.errors, formattedErrors);
                });
            }
            else {
                // otherwise it's a more generic error
                utils.registerWebpackErrors(compilation.errors, utils.formatErrors(errors, instance.loaderOptions, compiler, { file: filePath }));
            }
        });
        // gather all declaration files from TypeScript and output them to webpack
        Object.keys(filesToCheckForErrors)
            .filter(function (filePath) { return !!filePath.match(/\.ts(x?)$/); })
            .forEach(function (filePath) {
            var output = languageService.getEmitOutput(filePath);
            var declarationFile = output.outputFiles.filter(function (fp) { return !!fp.name.match(/\.d.ts$/); }).pop();
            if (declarationFile) {
                var assetPath = path.relative(compilation.compiler.context, declarationFile.name);
                compilation.assets[assetPath] = {
                    source: function () { return declarationFile.text; },
                    size: function () { return declarationFile.text.length; }
                };
            }
        });
        instance.filesWithErrors = filesWithErrors;
        instance.modifiedFiles = null;
        callback();
    };
}
/**
 * handle all other errors. The basic approach here to get accurate error
 * reporting is to start with a "blank slate" each compilation and gather
 * all errors from all files. Since webpack tracks errors in a module from
 * compilation-to-compilation, and since not every module always runs through
 * the loader, we need to detect and remove any pre-existing errors.
 */
function removeTSLoaderErrors(errors) {
    var index = -1;
    var length = errors.length;
    while (++index < length) {
        if (errors[index].loaderSource === 'ts-loader') {
            errors.splice(index--, 1);
            length--;
        }
    }
}
/**
 * Recursively collect all possible dependants of passed file
 */
function collectAllDependants(instance, fileName, collected) {
    if (collected === void 0) { collected = {}; }
    var result = {};
    result[fileName] = true;
    collected[fileName] = true;
    if (instance.reverseDependencyGraph[fileName]) {
        Object.keys(instance.reverseDependencyGraph[fileName]).forEach(function (dependantFileName) {
            if (!collected[dependantFileName]) {
                collectAllDependants(instance, dependantFileName, collected).forEach(function (fName) { return result[fName] = true; });
            }
        });
    }
    return Object.keys(result);
}
module.exports = makeAfterCompile;
